# [【MX-S11】梦熊 NOIP 2025 模拟赛 3（同步赛）](https://www.luogu.com.cn/contest/287508)

本蒟蒻又来打模拟赛了，这次希望至少切掉一道题，希望别爆零。

## A

### 题目描述

小 L 和小 K 发明了一种新的游戏。游戏将在一行 $n$ 个格子上进行，代表 $n$ 个城市，分别为城市 $1,2,\dots,n$。初始，城市 $i$ 有士兵 $a_i$ 人。两人约定，前 $m$ 个编号的城市是小 L 的地盘，其他城市是小 K 的地盘。

两人将交替进行操作，小 L 先手。轮到该方操作时，可以作出如下行动之一：

- 转移：选择己方地盘上的两个城市 $x,y$，满足 $|x-y|=1$，把城市 $x$ 的士兵全部转移到城市 $y$，即同时令 $a_y\leftarrow a_x+a_y$，$a_x\leftarrow 0$。
- 攻占：选择己方地盘上的城市 $x$ 和对方地盘上的城市 $y$，满足 $|x-y|=1$ 且轮到小 L 操作时需满足 $a_x>a_y$，轮到小 K 操作时需满足 $a_x\geq a_y$，攻占对方的城市 $y$，把城市 $x$ 的士兵全部转移到城市 $y$，即同时令 $a_y\leftarrow a_x+a_y$，$a_x\leftarrow 0$，把城市 $y$ 归到己方的地盘上。
- 不进行任何操作。

当一方将所有城市归为己方地盘时，该方获胜。如果两人都绝顶聪明的话，谁将获胜？请你对于 $m=1,2,\dots,n-1$ 分别输出 $m$ 取该值时问题的答案。

可以证明在双方绝顶聪明的情况下，博弈一定可以在有限次操作内结束。

### 想法

~~题意还是很好好理解的qwq，本蒟蒻看完题目的第一想法就是模拟，但是时间复杂度肯定会很高然后爆TLE。~~

注意到，任何情况下，我们都可以选择从前线依次向后转移，实现兵力的集中而不改变总兵力（不妨将此操作称为 **集中** 策略）。因此，在最优决策为 **集中** 策略时，我们可以直接比较总兵力的大小而决定胜负。

因此，最优策略将是尽可能使自己的总兵力增加，并保证兵力薄弱时从前线撤退。从第一回合开始思考双方的博弈策略，考虑前线：

$$
\begin{array}{|c|c|c|c|c|}
\hline
\textcolor{lime}\dots & \textcolor{lime}{a_m} & a_{m+1} & a_{m+2} & \dots \\
\hline
\end{array}
$$

小 L 先手，如下决策将会是最优解：

- 若 $a_m \le a_{m+1}$ ，如果不动前线，那就会被小 K 攻占，故只能从前线向后 **转移** 。
- 否则，我们可以选择 **攻占** ，于是模拟向前 **攻占** 后的情况，作如下讨论：
  - 若 $a_m+a_{m+1} \le a_{m+2}$ ，表明向前 **攻占** 后，会被小 K 反击 ~~（送人头）~~ ，故不能 **攻占** ，只能向后 **转移** 。
  - 否则，表明向前 **攻占** 后，不会遭到反击，故选择 **攻占** 。

之后是小 K 的回合，作讨论：

$$
\begin{array}{|c|c|c|c|c|}
\hline
\textcolor{lime}\dots & \textcolor{lime}{0} & a_{m+1} & a_{m+2} & \dots \\
\hline
\end{array}
$$

- 若小 L 向后转移，则我们无论如何也追不上小 L 的前线兵力，因此，双方执行 **集中** 策略。

$$
\begin{array}{|c|c|c|c|c|}
\hline
\textcolor{lime}\dots & \textcolor{lime}{0} & \textcolor{lime}{a_{m}+a_{m+1}} & a_{m+2} & \dots \\
\hline
\end{array}
$$

- 若小 L 向前推进，则由 $a_m+a_{m+1} \gt a_{m+2}$ 可知，我们的前线在该回合无法执行 **攻占** ，因此向后 **转移** ，小 K 也无法追上我们的前线兵力，因此，双方执行 **集中** 策略

可以看到从第二回合开始就已经进入 **集中** 策略了，因此只需要按照上述策略判定第一回合小 K 的行动，之后直接比较总兵力：
- 若小 K 拥有的总兵力大于总数的一半，无论如何均能获胜
- 否则：
  - 选择 **攻占** ，比较攻占后的兵力。
  - 选择 **转移** ，无论如何均会失败。

代码如下：

```cpp
// T545304 【MX-S11-T1】战争游戏
// CrispyXYZ
#include <bits/stdc++.h>
#include <vector>
#define rep(i,a,b) for(int i=a; i<=b; i++)
#define each(e,a) for(auto &&e: a)
#define all(v) v.begin(),v.end()
#define comp() [](auto &a, auto &b)
#define endl '\n'

using PII = std::pair<int,int>;
using VI = std::vector<int>;
using LL = long long;
using namespace std;

void solve() {
    int n;
    cin >> n;
    VI a(n+1); // 数组下标从0开始，多开1位防止越界
    a[n]=0;
    vector<LL> pres(n+1); // pres下标从1开始，便于计算
    pres[0]=0;
    LL sum=0;
    rep(i,0,n-1) {
        cin >> a[i];
        sum += a[i];
        pres[i+1] = pres[i] + a[i]; // 计算前缀和，节省时间
    }
    rep(m,1,n-1) { // 核心判定逻辑
        if(pres[m]*2 > sum
        ||(a[m-1]>a[m] && a[m-1]+a[m]>a[m+1] && pres[m+1]*2 > sum)) cout << 1;
        else cout << 0;

    }
    cout << endl;
}

signed main() {
    cin.tie(nullptr) -> ios::sync_with_stdio(false);
    int T;
    cin >> T;
    while(T--) {
        solve();
    }
    return 0;
}
```

## B & C

不会qwq，暴力dfs骗骗分

## D

题目好长，放弃了
